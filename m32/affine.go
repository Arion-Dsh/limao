package m32

//Affine is 3x3 matrix
// [m00, m01, m02]
// [m10, m11, m12]
// [0,   0,   1  ]
type Affine [2]Vec3

//Mul p * q
func (m *Affine) Mul(p, q *Affine) {
	m00 := p[0][0]*q[0][0] + p[0][1]*q[1][0]
	m01 := p[0][0]*q[0][1] + p[0][1]*q[1][1]
	m02 := p[0][0]*q[0][2] + p[0][1]*q[1][2] + p[0][2]
	m10 := p[1][0]*q[0][0] + p[1][1]*q[1][0]
	m11 := p[1][0]*q[0][1] + p[1][1]*q[1][1]
	m12 := p[1][0]*q[0][2] + p[1][1]*q[1][2] + p[1][2]
	m[0][0] = m00
	m[0][1] = m01
	m[0][2] = m02
	m[1][0] = m10
	m[1][1] = m11
	m[1][2] = m12
}

// Translate as m.Mul(p, &Affine{{1,0,x}, {0,1,y}})
// [1, 0, x]
// [0, 1, y]
// [0, 0, 1]
func (m *Affine) Translate(p *Affine, x, y float32) {
	m[0][0] = p[0][0]
	m[0][1] = p[0][1]
	m[0][2] = p[0][0]*x + p[0][1]*y + p[0][2]
	m[1][0] = p[1][0]
	m[1][1] = p[1][1]
	m[1][2] = p[1][0]*x + p[1][1]*y + p[1][2]
}

//Scale ...
func (m *Affine) Scale(p *Affine, x, y float32) {
	m[0][0] = p[0][0] * x
	m[0][1] = p[0][1] * y
	m[0][2] = p[0][2]
	m[1][0] = p[1][0] * x
	m[1][1] = p[1][1] * y
	m[1][2] = p[1][2]
}
